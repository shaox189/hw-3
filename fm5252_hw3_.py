# -*- coding: utf-8 -*-
"""FM5252 HW3 .ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/13w-PjBJXJOqcHouijoTQ7i457Dy5Gk-N
"""

import numpy as np
import scipy.stats as ss
from scipy.stats import norm

# Newton's Method to calculate implied volatility
def d(S,K,T,r,sigma):
  d1 =  (np.log(S/K)+(r+(sigma**2)/2)*T)/(sigma*np.sqrt(T))
  d2 =  (np.log(S/K)+(r-(sigma**2)/2)*T)/(sigma*np.sqrt(T))
  return d1, d2

def CallPrice(S,K,T,r,sigma):
  d1, d2 = d(S,K,T,r,sigma)
  C = S*norm.cdf(d1) - K*norm.cdf(d2)*np.exp(-r*T)
  return C

def PutPrice(S,K,T,r,sigma):
  d1, d2 = d(S,K,T,r,sigma)
  P = K*norm.cdf(-d2)*np.exp(-r*T) - S*norm.cdf(-d1)
  return P

def impVol_Newton(S,K,T,r,C0,P0,OptionType):
  #Tolerances
  tol = 1e-3
  epsilon = 1

  count=0
  max_iter=1000

  #initial guess
  vol = 0.5
  while epsilon > tol:
    count+=1
    if count >= max_iter:
      break
  
    orig_vol = vol
  
  #calculate the value of Call/Put Price
    d1,d2 = d(S,K,T,r,vol)
    if OptionType == 'C':
      function_value = CallPrice(S,K,T,r,vol) - C0
    else: 
      function_value = PutPrice(S,K,T,r,vol) - P0

  #calculate vega
    vega = S*norm.pdf(d1)*np.sqrt(T)

  #update value of volatility
    vol = -function_value/vega+vol

  return vol
  #print("Sigma = ", vol)

S = 100
K = 105
T = 2
r=0.01
C0=2.5
P0 = 2.3
OptionType = 'C'
print("implied Volatility = ",impVol_Newton(S,K,T,r,C0,P0,OptionType))

# Bisection Method to calculate implied volatility
def impVol_bisection_Call(S,K,T,r,Price):
  LowerVol = 0
  UpperVol = 1
  tol = 0.0000001
  while ((LowerVol - UpperVol >=tol) or (np.abs(CallPrice(S,K,T,r,LowerVol)-Price) >= tol) and (tol <= np.abs(CallPrice(S,K,T,r,UpperVol)-Price)-Price)):
    MidVol = (LowerVol + UpperVol) / 2
    if np.abs(CallPrice(S,K,T,r,MidVol)-Price) <= tol:
      break
    elif (CallPrice(S,K,T,r,LowerVol)-Price) * (CallPrice(S,K,T,r,MidVol)-Price) < 0:
      UpperVol = MidVol
    else:
      LowerVol = MidVol

  return LowerVol

print(impVol_bisection_Call(S, K, T, r, C0))

def impVol_bisection_Put(S,K,T,r,Price):
  LowerVol = 0
  UpperVol = 1
  tol = 0.0000001
  while ((LowerVol - UpperVol >=tol) or (np.abs(PutPrice(S,K,T,r,LowerVol)-Price) >= tol) and (tol <= np.abs(PutPrice(S,K,T,r,UpperVol)-Price)-Price)):
    MidVol = (LowerVol + UpperVol) / 2
    if np.abs(PutPrice(S,K,T,r,MidVol)-Price) <= tol:
      break
    elif (PutPrice(S,K,T,r,LowerVol)-Price) * (PutPrice(S,K,T,r,MidVol)-Price) < 0:
      UpperVol = MidVol
    else:
      LowerVol = MidVol

  return LowerVol

print(impVol_bisection_Put(105, 95, T, r,P0))

#SVI
S = 100
K = 105
T = 2
r=0.01
C0=2.5
P0 = 2.3
OptionType = 'C'
K = np.arange(100,150,5)
imp_vol = impVol_Newton(S,K,T,r,C0,P0,OptionType)

from scipy.optimize import curve_fit
def SVI(k,a,b,rho,m,sigma):
  w = a+b*(rho*(k-m)+np.sqrt((k-m)**2+sigma**2))
  return w

# k = log(K/F) where F is the forwarding price
# F = S0* e^(r*t)
#WL(k) = a + b(ρ − 1)(k − m) k → −∞
#WR(k) = a + b(ρ + 1)(k − m) k → ∞
S0 = 100

k = np.log(K/(S0*np.exp(r*T)))
popt,pcov = curve_fit(SVI,k,imp_vol,bounds=([-np.inf,0,-1,-np.inf,0],[np.inf,np.inf,1,np.inf,np.inf]))
print("The five parameters are: ",popt)